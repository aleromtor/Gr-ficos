<!DOCTYPE html>
<html>
<head>
    <title></title>
    <script type="text/javascript" src="auxiliars.js"></script>
    <script type="text/javascript" src="shader.js"></script>
    <script type="text/javascript" src="ubo.js"></script>
    <script type="text/javascript" src="cube.js"></script>
    <script type="text/javascript" src="gl-matrix.js"></script>
    <script type="text/javascript" src="geometry.js"></script>
    <style type="text/css">
    </style>
    <script type="text/javascript">
        const mat4 = glMatrix.mat4;
        const vec3 = glMatrix.vec3;
        const vec2 = glMatrix.vec2;
        // Converts from degrees to radians.
        Math.radians = function(degrees) {
          return degrees * Math.PI / 180;
        };
        // Converts from radians to degrees.
        Math.degrees = function(radians) {
          return radians * 180 / Math.PI;
        };
    </script>
<!--//////////////////////////////////////////////////////////////////////////////////////////////////////////////SHADER INICIAL-->
    <script id="shader-vs" type="x-shader/x-vertex">#version 300 es
        precision mediump float;
        layout (location = 0) in vec3 aPos;
        layout (location = 2) in vec2 aTexCoord;

        // Unif. Buffer Object
        uniform UBO {
            mat4 projection;
            mat4 view;
        };

        out vec2 texCoord;

        uniform mat4 model;
        void main( )
        {
            gl_Position = projection * view * model * vec4(aPos, 1.0);
            texCoord = aTexCoord*0.9;
        }
    </script>
    <script id="shader-fs" type="x-shader/x-fragment">#version 300 es
        precision mediump float;

        in vec2 texCoord;
        out vec4 fragColor;
        uniform sampler2D diffuseTexture;


        void main( )
        {
            vec3 color = texture(diffuseTexture, texCoord).rgb;
            fragColor = vec4(color ,1.0 );
            //fragColor=texture(diffuseTexture, texCoord);
        }
    </script>
<!--//////////////////////////////////////////////////////////////////////////////////////////////////////////////SHADER TIERRA-->
<script id="shader-planet-vs" type="x-shader/x-vertex">#version 300 es
    precision mediump float;
    layout (location = 0) in vec3 aPos;
    layout (location = 2) in vec2 aTexCoord;

    // Unif. Buffer Object
    uniform UBO {
        mat4 projection;
        mat4 view;
    };

    out vec2 texCoord;

    uniform mat4 model;
    void main( )
    {
        gl_Position = projection * view * model * vec4(aPos, 1.0);
        texCoord = aTexCoord*0.9;
    }
</script>
<script id="shader-planet-fs" type="x-shader/x-fragment">#version 300 es
    precision mediump float;

    in vec2 texCoord;
    out vec4 fragColor;
    uniform sampler2D diffuseTexture;
    uniform sampler2D normalTexture;
    uniform sampler2D specularTexture;


    void main( )
    {
        vec3 color1 = texture(diffuseTexture, texCoord).rgb;
        vec3 color2 = texture(normalTexture, texCoord).rgb;
        vec3 color3 = texture(specularTexture, texCoord).rgb;
        fragColor = vec4((color1+color2+color3)/3.0 ,1.0 );
    }
</script>
<!--///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// FIN DE SHADERS-->
    </head>
    <body>
        <canvas id="myCanvas" width="500" height="500"></canvas>
        <script type="text/javascript">
            const gl = createContext( "myCanvas" );

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////CREACION DE SHADERS
            let shaderProgram = new ShaderProgram( );
            shaderProgram.createVertexShader(
                document.getElementById( "shader-vs" ).text
                );
            shaderProgram.createFragmentShader(
                document.getElementById( "shader-fs" ).text
                );
                shaderProgram.compile( );
                shaderProgram.link( );
                shaderProgram.autocatching( );
            
            let ubo = new UBO( "UBO", shaderProgram, [ "projection", "view" ]);//uniformes que quieres compartir
            ubo.attachProgram( shaderProgram );
            const sphereGeo = createSphere( );
            const ringGeo = createRing( );

            var VAO, VBO, VBO2, VBO3, EBO;
                VAO = gl.createVertexArray();
                VBO = gl.createBuffer();
                VBO2 = gl.createBuffer();
                VBO3 = gl.createBuffer();
                EBO = gl.createBuffer ();
                gl.bindVertexArray(VAO);
                // position attribute
                gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array( sphereGeo.vertices ),gl.STATIC_DRAW);
                gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(0);
                // normal attribute
                gl.bindBuffer(gl.ARRAY_BUFFER, VBO2);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array( sphereGeo.normals ),
                gl.STATIC_DRAW);
                gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(1);
                // texCoord attribute
                gl.bindBuffer(gl.ARRAY_BUFFER, VBO3);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array( sphereGeo.texCoords ),
                gl.STATIC_DRAW);
                gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(2);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBO);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array( sphereGeo.indices ),
                gl.STATIC_DRAW);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////INICIO PROGRAMA
            const viewPos = vec3.fromValues(5.0, 0.0, 10.0);//posicion camara
            gl.clearColor(1.0, 0.0, 0.2, 1.0);//color gfondo
            gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

            const initialCameraPos = vec3.fromValues(5.0, 0.0, 10.0);
                var cameraPos = vec3.fromValues(5.0, 0.0, 10.0);
                var cameraFront = vec3.fromValues(0.0, 0.0, -1.0);
                var cameraUp = vec3.fromValues(0.0, 1.0, 0.0);

                function updateCameraView(viewMatrix) {
                    mat4.lookAt(viewMatrix, cameraPos, vec3.add(vec3.create(), cameraPos, cameraFront), cameraUp);
                }    

                var planets = [
                    {orbitSpeed: 4, translation: [5, 0, 0],  axis: [0,0,1], scale: [0.7, 0.7, 0.7], moon:1, image:"" },
                    {orbitSpeed: 5, translation: [3, 0, 0],  axis: [0,0,1], scale: [0.6, 0.6, 0.6], moon:0 ,image:""},
                    {orbitSpeed: 1, translation: [7, 0, 0],  axis: [0,0,1], scale: [0.8, 0.8, 0.8], moon:0,image:"" }
                ];

                var moons = [
                    {},
                    {orbitSpeed: 4, translation: [3, 0, 0],  axis: [0,0,1], scale: [0.2,0.2, 0.2]}
                ];

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////TEXTURAS
                //SOL
                var sunTexture = new Image( );
                var textureID = gl.createTexture( );
                sunTexture.onload = function( ) {
                    gl.bindTexture(gl.TEXTURE_2D, textureID);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, sunTexture);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                    gl.generateMipmap(gl.TEXTURE_2D);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                };
                sunTexture.src = "resources/sun.png";
                
                //LUNA
                var moonTexture = new Image( );
                var moonTextureID = gl.createTexture( );
                moonTexture.onload = function( ) {
                    gl.bindTexture(gl.TEXTURE_2D, moonTextureID);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, moonTexture);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.generateMipmap(gl.TEXTURE_2D);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                };
                moonTexture.src = "resources/moon.png";

                //TIERRA
                var planetTexture = new Image( );
                var planetTextureID = gl.createTexture( );
                planetTexture.onload = function( ) {
                    gl.bindTexture(gl.TEXTURE_2D, planetTextureID);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, planetTexture);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                    gl.generateMipmap(gl.TEXTURE_2D);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                };
                planetTexture.src = "resources/earth_diffuse.jpg";
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////RENDERFUNC
            function renderFunc( time )
            {
                gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
                gl.enable( gl.DEPTH_TEST );

                time *= 0.01; // to seconds

                var proj = mat4.create( );
                mat4.perspective(proj, Math.radians( 60.0 ), gl.canvas.width/gl.canvas.height, 0.001, 1000.0 );
                var view = mat4.create( );
                updateCameraView(view);

                shaderProgram.bind( );
                //INICIALIZAR RESTO DE SHADERS

                shaderProgram.setUniform3f("viewPos", viewPos[0],viewPos[1],viewPos[2]);

                // Aquí subimos los datos para la proyección y la vista
                ubo.uploadData( "projection", proj );
                ubo.uploadData( "view", view );
                ubo.uploadAll( ); // Esta llamada sube todos los datos de golpe
                
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////DRAWS

                //draw sun
                var m1 = mat4.create();
                mat4.rotate(m1, m1, Math.radians(time), [1, 0, 0]);
                mat4.translate(m1, m1, [0,0,0]);
                mat4.scale(m1, m1, [2,2,2]);

                gl.activeTexture( gl.TEXTURE0 );
                shaderProgram.setUniform1i( "diffuseTexture", 0 );
                gl.bindTexture( gl.TEXTURE_2D, textureID );

                gl.bindVertexArray(VAO);
                shaderProgram.setUniformMat4("model", m1);
                gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_INT, 0);
                
                for (var i = 0; i < planets.length; i++) {

                    //planet creation
                    var planet= planets[i];

                    //planet translation
                    var m1 = mat4.create();
                    mat4.rotate(m1, m1, Math.radians(time * planet.orbitSpeed), planet.axis);
                    mat4.translate(m1, m1, planet.translation);

                    //planet rotation
                    var m2 = mat4.create();
                    gl.bindVertexArray(VAO);
                    mat4.translate(m1, m1, planet.translation);
                    mat4.rotate(m1, m1, Math.radians(time), planet.axis);

                    //model creation
                    var model= mat4.create();
                    mat4.multiply(model, m1, m2);
                    mat4.scale(model, model, planet.scale);
                    gl.activeTexture( gl.TEXTURE0 );
                    shaderProgram.setUniform1i( "diffuseTexture", 0 );
                    gl.bindTexture( gl.TEXTURE_2D, planetTextureID );

                    //print model
                    shaderProgram.setUniformMat4("model", model);
                    gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_INT, 0);
                        
                    if (planet.moon!=0){
                        //moon creation
                        var moon=moons[planet.moon];

                        //moon translation
                        var mL = mat4.create();
                        mat4.rotate(mL, mL, Math.radians(time * moon.orbitSpeed), moon.axis);
                        mat4.translate(mL, mL, moon.translation);

                        mat4.multiply(mL, m1, mL);
                        mat4.scale(mL, mL, moon.scale);

                        gl.activeTexture( gl.TEXTURE0 );
                        shaderProgram.setUniform1i( "diffuseTexture", 0 );
                        gl.bindTexture( gl.TEXTURE_2D, moonTextureID );
                        gl.bindVertexArray(VAO);
                        shaderProgram.setUniformMat4("model", mL);
                        gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_INT, 0);
                    }
                }
                resizeCanvas();
                requestAnimationFrame( renderFunc );
            }
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////MOVIMIENTOS DE LA CAMARA
            var lastX = 0.0;
            var lastY = 0.0;
            var yaw = -90.0; // ajusta según sea necesario
            var pitch = 0.0; // ajusta según sea necesario
            var sensitivity = 0.1; // ajusta según sea necesario


            document.addEventListener('keydown', function (event) {
                    const cameraSpeed = 0.1; // ajusta según sea necesario
                    const lightMoveSpeed = 0.5;
                    switch (event.key) {
                        case 'w':
                            vec3.add(cameraPos, cameraPos, vec3.scale(vec3.create(), cameraFront, cameraSpeed));
                            break;
                        case 's':
                            vec3.subtract(cameraPos, cameraPos, vec3.scale(vec3.create(), cameraFront, cameraSpeed));
                            break;
                        case 'a':
                            vec3.subtract(cameraPos, cameraPos, vec3.scale(vec3.create(), vec3.normalize(vec3.create(), vec3.cross(vec3.create(), cameraFront, cameraUp)), cameraSpeed));
                            break;
                        case 'd':
                            vec3.add(cameraPos, cameraPos, vec3.scale(vec3.create(), vec3.normalize(vec3.create(), vec3.cross(vec3.create(), cameraFront, cameraUp)), cameraSpeed));
                            break;
                        case 'ArrowUp':
                            vec3.add(cameraPos, cameraPos, vec3.scale(vec3.create(), cameraUp, cameraSpeed));
                            break;
                        case 'ArrowDown':
                            vec3.subtract(cameraPos, cameraPos, vec3.scale(vec3.create(), cameraUp, cameraSpeed));
                            break;
                        case 'p': 
                            vec3.copy(cameraPos, initialCameraPos); // Restablecer posición
                            yaw = -90.0; // Restablecer yaw
                            pitch = 0.0; // Restablecer pitch
                            // Recalcular dirección frontal de la cámara
                            var front = vec3.create();
                            front[0] = Math.cos(glMatrix.glMatrix.toRadian(yaw)) * Math.cos(glMatrix.glMatrix.toRadian(pitch));
                            front[1] = Math.sin(glMatrix.glMatrix.toRadian(pitch));
                            front[2] = Math.sin(glMatrix.glMatrix.toRadian(yaw)) * Math.cos(glMatrix.glMatrix.toRadian(pitch));
                            vec3.normalize(cameraFront, front);
                            break;

                    }
                });

            document.addEventListener('mousemove', function (event) {
                    if (isMousePressed) {
                        var xOffset = event.clientX - lastX;
                        var yOffset = lastY - event.clientY; // inverso porque el eje Y del mouse está invertido

                        lastX = event.clientX;
                        lastY = event.clientY;

                        xOffset *= sensitivity;
                        yOffset *= sensitivity;

                        yaw += xOffset;
                        pitch += yOffset;

                        // No limitar los ángulos pitch para rotar completamente
                        var front = vec3.create();
                        front[0] = Math.cos(Math.radians(yaw)) * Math.cos(Math.radians(pitch));
                        front[1] = Math.sin(Math.radians(pitch));
                        front[2] = Math.sin(Math.radians(yaw)) * Math.cos(Math.radians(pitch));
                        vec3.normalize(cameraFront, front);
                    }
                });

                var isMousePressed = false;

                document.addEventListener('mousedown', function (event) {
                    isMousePressed = true;
                    lastX = event.clientX;
                    lastY = event.clientY;
                });

                document.addEventListener('mouseup', function () {
                    isMousePressed = false;});
            function resizeCanvas()
            {
                const canvas = gl.canvas;
                // Lookup the size the browser is displaying the canvas in CSS pixels.
                const displayWidth  = window.innerWidth;
                const displayHeight = window.innerHeight;

                // Check if the canvas is not the same size.
                const needResize = canvas.width  !== displayWidth ||
                                canvas.height !== displayHeight;

                if (needResize) {
                    // Make the canvas the same size
                    canvas.width  = displayWidth;
                    canvas.height = displayHeight;
                    gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );
                }
            }

            renderFunc( 0.0 );
        </script>
    </body>
    </html>