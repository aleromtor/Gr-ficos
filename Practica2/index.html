<!DOCTYPE html>
<html>
<head>
    <title></title>
    <script type="text/javascript" src="auxiliars.js"></script>
    <script type="text/javascript" src="shader.js"></script>
    <script type="text/javascript" src="ubo.js"></script>
    <script type="text/javascript" src="cube.js"></script>
    <script type="text/javascript" src="gl-matrix.js"></script>
    <script type="text/javascript" src="geometry.js"></script>
    <style type="text/css">
        /*canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        body
        {
            margin: 0;
            overflow: hidden;
        }*/

    </style>
    <script type="text/javascript">
        const mat4 = glMatrix.mat4;
        const vec3 = glMatrix.vec3;
        const vec2 = glMatrix.vec2;
        // Converts from degrees to radians.
        Math.radians = function(degrees) {
          return degrees * Math.PI / 180;
        };
         
        // Converts from radians to degrees.
        Math.degrees = function(radians) {
          return radians * 180 / Math.PI;
        };
    </script>
<script id="shader-vs" type="x-shader/x-vertex">#version 300 es
precision mediump float;
layout (location = 0) in vec3 aPos;

// Unif. Buffer Object
uniform UBO {
    mat4 projection;
    mat4 view;
};

uniform mat4 model;
void main( )
{
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}

</script>

<script id="shader-fs" type="x-shader/x-fragment">#version 300 es
precision mediump float;

out vec4 fragColor;

void main( )
{
    fragColor = vec4( 1.0,1.0,1.0,1.0 );
}
</script>

</head>
<body>
<canvas id="myCanvas" width="500" height="500"></canvas>
<script type="text/javascript">
    const gl = createContext( "myCanvas" );

    // ---------------------------------------------------
    // CREAR TODOS LOS SHADERPROGRAMS QUE NECESITES
    // ---------------------------------------------------
    let shaderProgram = new ShaderProgram( );
    shaderProgram.createVertexShader(
           document.getElementById( "shader-vs" ).text
        );
    shaderProgram.createFragmentShader(
           document.getElementById( "shader-fs" ).text
        );
        shaderProgram.compile( );
        shaderProgram.link( );
        shaderProgram.autocatching( );

    // ---------------------------------------------------
    // CREAMOS EL UBO Y VINCULAMOS TODOS LOS SHADERPROGRAM
    // QUE HARÁN USO DE ESTE UBO
    // ---------------------------------------------------
    // TODO: ShaderProgram debe ser algún Programa que crees y que contenga el UBO
    
    let ubo = new UBO( "UBO", shaderProgram, [ "projection", "view" ]); // Aquí añade todos los uniformes que quieres compartir


    
    // TODO: Realiza esta llamada con cada programa que vayas a utilizar 
    ubo.attachProgram( shaderProgram );



    // ---------------------------------------------------
    // CREA EL VAO, VBO'S Y EBO PARA LA ESFERA (createSphere())
    // CREA EL VAO, VOB'S Y EBO PARA EL ANILLO (createRing())
    //  {
    //    "vertices": vertices,
    //    normals: normals,
    //    texCoords: uvs,
    //    indices: indices
    // }
    // ---------------------------------------------------
    // TODO: Crea una esfera y sube la geometría a la tarjeta gráfica
    const sphereGeo = createSphere( );
    const ringGeo = createRing( );

    var VAO, VBO, VBO2, VBO3, EBO;
        VAO = gl.createVertexArray();
        VBO = gl.createBuffer();
        VBO2 = gl.createBuffer();
        VBO3 = gl.createBuffer();
        EBO = gl.createBuffer ();
        gl.bindVertexArray(VAO);
        // position attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array( sphereGeo.vertices ),gl.STATIC_DRAW);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(0);
        // normal attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO2);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array( sphereGeo.normals ),
        gl.STATIC_DRAW);
        gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(1);
        // texCoord attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO3);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array( sphereGeo.textCoords ),
        gl.STATIC_DRAW);
        gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(2);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBO);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array( sphereGeo.indices ),
        gl.STATIC_DRAW);

    const viewPos = vec3.fromValues(5.0, 0.0, 10.0);

    gl.clearColor(1.0, 0.0, 0.2, 1.0);

    gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

    const initialCameraPos = vec3.fromValues(5.0, 0.0, 10.0);
        var cameraPos = vec3.fromValues(0.0, 0.0, 20.0);
        var cameraFront = vec3.fromValues(0.0, 0.0, -1.0);
        var cameraUp = vec3.fromValues(1.0, 0.0, 0.0);

        function updateCameraView(viewMatrix) {
            mat4.lookAt(viewMatrix, cameraPos, vec3.add(vec3.create(), cameraPos, cameraFront), cameraUp);
        }    

        var planets = [
            {orbitSpeed: 4, translation: [5, 0, 0],  axis: [0,0,1], scale: [0.7, 0.7, 0.7], moon:1 },
            {orbitSpeed: 5, translation: [3, 0, 0],  axis: [0,0,1], scale: [0.6, 0.6, 0.6], moon:0 },
            {orbitSpeed: 1, translation: [7, 0, 0],  axis: [0,0,1], scale: [0.8, 0.8, 0.8], moon:0 }
        ];

        var moons = [
            {},
            {orbitSpeed: 4, translation: [3, 0, 0],  axis: [0,0,1], scale: [0.2,0.2, 0.2]}
        ];

    function renderFunc( time )
    {
        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
        gl.enable( gl.DEPTH_TEST );

        time *= 0.01; // to seconds

    	var proj = mat4.create( );
    	mat4.perspective(proj, Math.radians( 60.0 ), gl.canvas.width/gl.canvas.height, 0.001, 1000.0 );
    	var view = mat4.create( );
        //mat4.translate( view, view, [ 0.0, 0.0, -20.0 ] );
        updateCameraView(view);

        // TODO: Tienes que activar al menos un programa
        shaderProgram.bind( );

        shaderProgram.setUniform3f("viewPos", viewPos[0],viewPos[1],viewPos[2]);

        // Aquí subimos los datos para la proyección y la vista
        ubo.uploadData( "projection", proj );
        ubo.uploadData( "view", view );
        //ubo.uploadData( "model", mat4.create( ) );
        ubo.uploadAll( ); // Esta llamada sube todos los datos de golpe
        
        // A partir de aquí, subimos matriz model y demás cosas para cada esfera.

        
        //draw sun
        var m1 = mat4.create();
        mat4.rotate(m1, m1, Math.radians(time), [1, 0, 0]);
        mat4.translate(m1, m1, [0,0,0]);
        mat4.scale(m1, m1, [2,2,2]);
        gl.bindVertexArray(VAO);
        shaderProgram.setUniformMat4("model", m1);
        gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length*2, gl.UNSIGNED_SHORT, 0);
        



        for (var i = 0; i < planets.length; i++) {

            //planet creation
            var planet= planets[i];

            //planet translation
            var m1 = mat4.create();
            mat4.rotate(m1, m1, Math.radians(time * planet.orbitSpeed), planet.axis);
            mat4.translate(m1, m1, planet.translation);

            //planet rotation
            var m2 = mat4.create();
            gl.bindVertexArray(VAO);
            mat4.translate(m1, m1, planet.translation);
            mat4.rotate(m1, m1, Math.radians(time), planet.axis);

            //model creation
            var model= mat4.create();
            mat4.multiply(model, m1, m2);
            mat4.scale(model, model, planet.scale);

            //print model
            shaderProgram.setUniformMat4("model", model);
            gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length*2, gl.UNSIGNED_SHORT, 0);

            if (planet.moon!=0){
                //moon creation
                var moon=moons[planet.moon];

                //moon translation
                var mL = mat4.create();
                mat4.rotate(mL, mL, Math.radians(time * moon.orbitSpeed), moon.axis);
                mat4.translate(mL, mL, moon.translation);

                mat4.multiply(mL, m1, mL);
                mat4.scale(mL, mL, moon.scale);
                gl.bindVertexArray(VAO);
                shaderProgram.setUniformMat4("model", mL);
                gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length*2, gl.UNSIGNED_SHORT, 0);
            }
        }
        resizeCanvas();
        requestAnimationFrame( renderFunc );
    }

    document.addEventListener('keydown', function(event) {
        /*
            65 => A
            68 => D
            83 => S
            87 => W
            81 => Q
            69 => E

            37 => Flecha izq
            39 => Fecha drcha
            38 => Fecha arriba
            40 => Fecha abajo

        */
        if( event.keyCode == 81 ) // Q
        {
        }
        
    } );


    var lastX = 0.0;
        var lastY = 0.0;
        var yaw = -90.0; // ajusta según sea necesario
        var pitch = 0.0; // ajusta según sea necesario
        var sensitivity = 0.1; // ajusta según sea necesario


    document.addEventListener('keydown', function (event) {
            const cameraSpeed = 0.1; // ajusta según sea necesario
            const lightMoveSpeed = 0.5;
            switch (event.key) {
                case 'w':
                    vec3.add(cameraPos, cameraPos, vec3.scale(vec3.create(), cameraFront, cameraSpeed));
                    break;
                case 's':
                    vec3.subtract(cameraPos, cameraPos, vec3.scale(vec3.create(), cameraFront, cameraSpeed));
                    break;
                case 'a':
                    vec3.subtract(cameraPos, cameraPos, vec3.scale(vec3.create(), vec3.normalize(vec3.create(), vec3.cross(vec3.create(), cameraFront, cameraUp)), cameraSpeed));
                    break;
                case 'd':
                    vec3.add(cameraPos, cameraPos, vec3.scale(vec3.create(), vec3.normalize(vec3.create(), vec3.cross(vec3.create(), cameraFront, cameraUp)), cameraSpeed));
                    break;
                case 'ArrowUp':
                    vec3.add(cameraPos, cameraPos, vec3.scale(vec3.create(), cameraUp, cameraSpeed));
                    break;
                case 'ArrowDown':
                    vec3.subtract(cameraPos, cameraPos, vec3.scale(vec3.create(), cameraUp, cameraSpeed));
                    break;
                case 'p': 
                    vec3.copy(cameraPos, initialCameraPos); // Restablecer posición
                    yaw = -90.0; // Restablecer yaw
                    pitch = 0.0; // Restablecer pitch
                    // Recalcular dirección frontal de la cámara
                    var front = vec3.create();
                    front[0] = Math.cos(glMatrix.glMatrix.toRadian(yaw)) * Math.cos(glMatrix.glMatrix.toRadian(pitch));
                    front[1] = Math.sin(glMatrix.glMatrix.toRadian(pitch));
                    front[2] = Math.sin(glMatrix.glMatrix.toRadian(yaw)) * Math.cos(glMatrix.glMatrix.toRadian(pitch));
                    vec3.normalize(cameraFront, front);
                    break;
                
            }
        });

    document.addEventListener('mousemove', function (event) {
            if (isMousePressed) {
                var xOffset = event.clientX - lastX;
                var yOffset = lastY - event.clientY; // inverso porque el eje Y del mouse está invertido

                lastX = event.clientX;
                lastY = event.clientY;

                xOffset *= sensitivity;
                yOffset *= sensitivity;

                yaw += yOffset;
                pitch += xOffset;

                // No limitar los ángulos pitch para rotar completamente
                var front = vec3.create();
                front[0] = Math.cos(Math.radians(yaw)) * Math.cos(Math.radians(pitch));
                front[1] = Math.sin(Math.radians(pitch));
                front[2] = Math.sin(Math.radians(yaw)) * Math.cos(Math.radians(pitch));
                vec3.normalize(cameraFront, front);
            }
        });

        var isMousePressed = false;

        document.addEventListener('mousedown', function (event) {
            isMousePressed = true;
            lastX = event.clientX;
            lastY = event.clientY;
        });

        document.addEventListener('mouseup', function () {
            isMousePressed = false;});

    function resizeCanvas()
    {
        const canvas = gl.canvas;
        // Lookup the size the browser is displaying the canvas in CSS pixels.
        const displayWidth  = window.innerWidth;
        const displayHeight = window.innerHeight;

        // Check if the canvas is not the same size.
        const needResize = canvas.width  !== displayWidth ||
                           canvas.height !== displayHeight;

        if (needResize) {
            // Make the canvas the same size
            canvas.width  = displayWidth;
            canvas.height = displayHeight;
            gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );
        }
    }

    //window.addEventListener('resize', resizeCanvas);
    //resizeCanvas();

    renderFunc( 0.0 );
</script>
</body>
</html>