<!DOCTYPE html>
<html>

<head>
    <title></title>
    <script type="text/javascript" src="auxiliars.js"></script>
    <script type="text/javascript" src="shader.js"></script>
    <script type="text/javascript" src="ubo.js"></script>
    <script type="text/javascript" src="cube.js"></script>
    <script type="text/javascript" src="gl-matrix.js"></script>
    <script type="text/javascript" src="geometry.js"></script>
    <style type="text/css">
    </style>
    <script type="text/javascript">
        const mat4 = glMatrix.mat4;
        const vec3 = glMatrix.vec3;
        const vec2 = glMatrix.vec2;
        // Converts from degrees to radians.
        Math.radians = function (degrees) {
            return degrees * Math.PI / 180;
        };
        // Converts from radians to degrees.
        Math.degrees = function (radians) {
            return radians * 180 / Math.PI;
        };
    </script>
    <!--//////////////////////////////////////////////////////////////////////////////////////////////////////////////SHADER INICIAL-->
    <script id="shader-vs" type="x-shader/x-vertex">#version 300 es
        precision mediump float;
        layout (location = 0) in vec3 aPos;
        layout (location = 1) in vec3 aNormal; // Add normal attribute
        layout (location = 2) in vec2 aTexCoord;

        // Unif. Buffer Object
        uniform UBO {
            mat4 projection;
            mat4 view;
        };

        out vec2 TexCoord;
        out vec3 Normal;  // Output normal for fragment shader
        out vec3 FragPos; // Output fragment position

        uniform mat4 model;
        void main( )
        {
            gl_Position = projection * view * model * vec4(aPos, 1.0);
            TexCoord = aTexCoord*0.9;
            FragPos = vec3(model * vec4(aPos, 1.0));
            Normal = mat3(transpose(inverse(model))) * aNormal;  // Calculate normal in world space
        }

    </script>
    <script id="shader-fs" type="x-shader/x-fragment">#version 300 es
precision mediump float;

in vec2 TexCoord;
in vec3 Normal;   // Input normal from vertex shader
in vec3 FragPos;  // Input fragment position

out vec4 fragColor;

uniform sampler2D diffuseTexture;
uniform vec3 lightPos;  // Add light position uniform
uniform vec3 viewPos;   // Add view position uniform

void main( )
{
    // Ambient
    vec3 ambient = 0.1 * texture(diffuseTexture, TexCoord).rgb;

    // Diffuse
    vec3 lightDir = normalize(lightPos - FragPos);
    vec3 norm = normalize(Normal);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * texture(diffuseTexture, TexCoord).rgb;

    // Specular (Simplified - no specular map)
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 reflectDir = reflect(-lightDir, norm);  
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
    vec3 specular = spec * vec3(1.0); // White specular highlight

    fragColor = vec4((ambient + diffuse + specular), 1.0);
}
    </script>
    <!--//////////////////////////////////////////////////////////////////////////////////////////////////////////////SHADER TIERRA-->
    <script id="shader-planet-vs" type="x-shader/x-vertex">#version 300 es
        precision mediump float;

// Vertex Shader
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoord;

uniform UBO {
    mat4 projection;
    mat4 view;
};

out vec2 TexCoord;
out vec3 Normal;
out vec3 FragPos;

uniform mat4 model;

void main() {
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    TexCoord = aTexCoord * 0.9;
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
}

    </script>
    <script id="shader-planet-fs" type="x-shader/x-fragment">#version 300 es
        precision mediump float;
    
        in vec2 TexCoord;
in vec3 Normal;
in vec3 FragPos;

out vec4 fragColor;

uniform sampler2D texture1;
uniform sampler2D texture2;
uniform sampler2D texture3;

uniform vec3 lightPos;
uniform vec3 viewPos;

void main() {
    // Ambient
    vec3 ambient = 0.1 * (texture(texture1, TexCoord).rgb + 
                           texture(texture2, TexCoord).rgb + 
                           texture(texture3, TexCoord).rgb);

    // Diffuse
    vec3 lightDir = normalize(lightPos - FragPos);
    vec3 norm = normalize(Normal);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * (texture(texture1, TexCoord).rgb + 
                           texture(texture2, TexCoord).rgb + 
                           texture(texture3, TexCoord).rgb);

    // Specular (Simplified - no specular map)
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 reflectDir = reflect(-lightDir, norm);  
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
    vec3 specular = spec * vec3(1.0);

    fragColor = vec4((ambient + diffuse + specular), 1.0);
}

    </script>
    <!--//////////////////////////////////////////////////////////////////////////////////////////////////////////////SHADER SUN-->
    <script id="shader-sun-vs" type="x-shader/x-vertex">#version 300 es
    precision mediump float;
    layout (location = 0) in vec3 aPos;
    layout (location = 2) in vec2 aTexCoord;

    // Unif. Buffer Object
    uniform UBO {
        mat4 projection;
        mat4 view;
    };

    out vec2 texCoord;

    uniform mat4 model;
    void main( )
    {
        gl_Position = projection * view * model * vec4(aPos, 1.0);
        texCoord = aTexCoord*0.9;
    }
</script>
    <script id="shader-sun-fs" type="x-shader/x-fragment">#version 300 es
    precision mediump float;

    in vec2 texCoord;
    out vec4 fragColor;
    uniform sampler2D diffuseTexture;


    void main( )
    {
        vec3 color = texture(diffuseTexture, texCoord).rgb;
        fragColor = vec4(color ,1.0 );
    }
</script>
    <!--///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// FIN DE SHADERS-->
</head>

<body>
    <canvas id="myCanvas" width="500" height="500"></canvas>
    <script type="text/javascript">
        const gl = createContext("myCanvas");

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////CREACION DE SHADERS
        let shaderProgram = new ShaderProgram();
        shaderProgram.createVertexShader(
            document.getElementById("shader-vs").text
        );
        shaderProgram.createFragmentShader(
            document.getElementById("shader-fs").text
        );
        shaderProgram.compile();
        shaderProgram.link();
        shaderProgram.autocatching();

        let planetShaderProgram = new ShaderProgram();
        planetShaderProgram.createVertexShader(
            document.getElementById("shader-planet-vs").text
        );
        planetShaderProgram.createFragmentShader(
            document.getElementById("shader-planet-fs").text
        );
        planetShaderProgram.compile();
        planetShaderProgram.link();
        planetShaderProgram.autocatching();

        let sunShaderProgram = new ShaderProgram();
        sunShaderProgram.createVertexShader(
            document.getElementById("shader-sun-vs").text
        );
        sunShaderProgram.createFragmentShader(
            document.getElementById("shader-sun-fs").text
        );
        sunShaderProgram.compile();
        sunShaderProgram.link();
        sunShaderProgram.autocatching();

        let ubo = new UBO("UBO", shaderProgram, ["projection", "view"]);//uniformes que quieres compartir
        ubo.attachProgram(shaderProgram);
        ubo.attachProgram(planetShaderProgram);
        ubo.attachProgram(sunShaderProgram);

        const sphereGeo = createSphere();
        const ringGeo = createRing();

        var VAO, VBO, VBO2, VBO3, EBO;
        VAO = gl.createVertexArray();
        VBO = gl.createBuffer();
        VBO2 = gl.createBuffer();
        VBO3 = gl.createBuffer();
        EBO = gl.createBuffer();
        gl.bindVertexArray(VAO);
        // position attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereGeo.vertices), gl.STATIC_DRAW);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(0);
        // normal attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO2);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereGeo.normals),
            gl.STATIC_DRAW);
        gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(1);
        // texCoord attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO3);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereGeo.texCoords),
            gl.STATIC_DRAW);
        gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(2);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBO);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(sphereGeo.indices),
            gl.STATIC_DRAW);
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////INICIO PROGRAMA
        const viewPos = vec3.fromValues(5.0, 0.0, 20.0);//posicion camara
        gl.clearColor(0.0, 0.0, 0.0, 1.0);//color gfondo
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        const initialCameraPos = vec3.fromValues(5.0, 0.0, 20.0);
        var cameraPos = vec3.fromValues(5.0, 0.0, 20.0);
        var cameraFront = vec3.fromValues(0.0, 0.0, -1.0);
        var cameraUp = vec3.fromValues(0.0, 1.0, 0.0);

        function updateCameraView(viewMatrix) {
            mat4.lookAt(viewMatrix, cameraPos, vec3.add(vec3.create(), cameraPos, cameraFront), cameraUp);
        }

        //creamos un array para introducir las texturas de los planetas
        var arrayTextures = [];

        var planets = [
            { orbitSpeed: 4, translation: [5, 0, 0], axis: [0, 0, 1], scale: [0.7, 0.7, 0.7], moon: 1, image: "" },
            { orbitSpeed: 5, translation: [3, 0, 0], axis: [0, 0, 1], scale: [0.6, 0.6, 0.6], moon: 0, image: "" },
            { orbitSpeed: 1, translation: [7, 0, 0], axis: [0, 0, 1], scale: [0.8, 0.8, 0.8], moon: 0, image: "" },
            { orbitSpeed: 1.1, translation: [10, 0, 0], axis: [0, 0, 1], scale: [1, 1, 1], moon: 0, image: "" }
        ];

        var moons = [
            {},
            { orbitSpeed: 4, translation: [3, 0, 0], axis: [0, 0, 1], scale: [0.2, 0.2, 0.2] }
        ];

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////TEXTURAS
        //SOL
        var sunTexture = new Image();
        var textureID = gl.createTexture();
        sunTexture.onload = function () {
            gl.bindTexture(gl.TEXTURE_2D, textureID);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, sunTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
        };
        sunTexture.src = "resources/sun.png";

        //LUNA
        var moonTexture = new Image();
        var moonTextureID = gl.createTexture();
        moonTexture.onload = function () {
            gl.bindTexture(gl.TEXTURE_2D, moonTextureID);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, moonTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
        };
        moonTexture.src = "resources/moon.png";

        //TIERRA
        var planetTexture = new Image();
        var planetTextureID = gl.createTexture();
        arrayTextures.push(planetTextureID);
        planetTexture.onload = function () {
            gl.bindTexture(gl.TEXTURE_2D, planetTextureID);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, planetTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
        };
        planetTexture.src = "resources/earth_diffuse.jpg";

        var planetNormalTexture = new Image();
        var planetNormalTextureID = gl.createTexture();
        planetNormalTexture.onload = function () {
            gl.bindTexture(gl.TEXTURE_2D, planetNormalTextureID);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, planetNormalTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
        };
        planetNormalTexture.src = "resources/earth_normal.jpg";

        var planetSpecularTexture = new Image();
        var planetSpecularTextureID = gl.createTexture();
        planetSpecularTexture.onload = function () {
            gl.bindTexture(gl.TEXTURE_2D, planetSpecularTextureID);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, planetSpecularTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
        };
        planetSpecularTexture.src = "resources/earth_specular.jpg";

        //MERCURIO
        var mercurioTexture = new Image();
        var mercurioTextureID = gl.createTexture();
        arrayTextures.push(mercurioTextureID);
        mercurioTexture.onload = function () {
            gl.bindTexture(gl.TEXTURE_2D, mercurioTextureID);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, mercurioTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
        };
        mercurioTexture.src = "resources/mercurio.jpg";

        //MARTE
        var marteTexture = new Image();
        var marteTextureID = gl.createTexture();
        arrayTextures.push(marteTextureID);
        marteTexture.onload = function () {
            gl.bindTexture(gl.TEXTURE_2D, marteTextureID);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, marteTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
        };
        marteTexture.src = "resources/marte.jpg";

        //JUPITER
        var jupiterTexture = new Image();
        var jupiterTextureID = gl.createTexture();
        arrayTextures.push(jupiterTextureID);
        jupiterTexture.onload = function () {
            gl.bindTexture(gl.TEXTURE_2D, jupiterTextureID);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, jupiterTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
        };
        jupiterTexture.src = "resources/jupiter.jpg";

        let cameraPlanet=false;

////////////////////////////////////////////////////////////////////////////////////////////////////RENDERFUNC
        function renderFunc(time) {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            time *= 0.01; // to seconds

            var proj = mat4.create();
            mat4.perspective(proj, Math.radians(60.0), gl.canvas.width / gl.canvas.height, 0.001, 1000.0);
            var view = mat4.create();
            updateCameraView(view);

            ubo.uploadData("projection", proj);
            ubo.uploadData("view", view);
            ubo.uploadAll();
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////DRAWS

            //draw sun
            sunShaderProgram.bind();
            var m1 = mat4.create();
            mat4.rotate(m1, m1, Math.radians(time), [1, 0, 0]);
            mat4.translate(m1, m1, [0, 0, 0]);
            mat4.scale(m1, m1, [2, 2, 2]);

            gl.activeTexture(gl.TEXTURE0);
            sunShaderProgram.setUniform1i("diffuseTexture", 0);
            gl.bindTexture(gl.TEXTURE_2D, textureID);

            gl.bindVertexArray(VAO);
            sunShaderProgram.setUniformMat4("model", m1);
            gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_INT, 0);

            for (var i = 0; i < planets.length; i++) {

                //planet creation
                var planet = planets[i];

                //planet translation
                var m1 = mat4.create();
                mat4.rotate(m1, m1, Math.radians(time * planet.orbitSpeed), planet.axis);
                mat4.translate(m1, m1, planet.translation);

                //planet rotation
                var m2 = mat4.create();
                gl.bindVertexArray(VAO);
                mat4.translate(m1, m1, planet.translation);
                mat4.rotate(m1, m1, Math.radians(time), planet.axis);

                //model creation
                var model = mat4.create();
                mat4.multiply(model, m1, m2);
                mat4.scale(model, model, planet.scale);

                if (i == 0) {
                    planetShaderProgram.bind();
                    planetShaderProgram.setUniform3f("lightPos", 0, 0, 0);
                    planetShaderProgram.setUniform3f("viewPos", viewPos[0], viewPos[1], viewPos[2]);

                    // Activar la textura dentro de la función de renderizado
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, planetTextureID);
                    planetShaderProgram.setUniform1i("diffuseTexture", 0);

                    gl.activeTexture(gl.TEXTURE1);
                    gl.bindTexture(gl.TEXTURE_2D, planetNormalTextureID);
                    planetShaderProgram.setUniform1i("normalTexture", 1);

                    gl.activeTexture(gl.TEXTURE2);
                    gl.bindTexture(gl.TEXTURE_2D, planetSpecularTextureID);
                    planetShaderProgram.setUniform1i("specularTexture", 2);

                    planetShaderProgram.setUniformMat4("model", model);
                    gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_INT, 0);

                    if (cameraPlanet) {
                        var earthPosition = vec3.create();
                        mat4.getTranslation(earthPosition, model); // Extract translation component
                        vec3.copy(cameraPos, [earthPosition[0]+1, earthPosition[1]+1, earthPosition[2]+1]);
                        updateCameraView(view);
                        ubo.uploadData("view", view);
                        ubo.uploadAll();
                    }

                } else {
                    shaderProgram.bind();
                    gl.activeTexture(gl.TEXTURE0);
                    shaderProgram.setUniform1i("diffuseTexture", 0);
                    gl.bindTexture(gl.TEXTURE_2D, arrayTextures[i]);
                    shaderProgram.setUniformMat4("model", model);
                    gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_INT, 0);
                }



                if (planet.moon != 0) {
                    //moon creation
                    var moon = moons[planet.moon];

                    //moon translation
                    var mL = mat4.create();
                    mat4.rotate(mL, mL, Math.radians(time * moon.orbitSpeed), moon.axis);
                    mat4.translate(mL, mL, moon.translation);

                    mat4.multiply(mL, m1, mL);
                    mat4.scale(mL, mL, moon.scale);

                    shaderProgram.bind();
                    gl.activeTexture(gl.TEXTURE0);
                    shaderProgram.setUniform1i("diffuseTexture", 0);
                    gl.bindTexture(gl.TEXTURE_2D, moonTextureID);
                    gl.bindVertexArray(VAO);
                    shaderProgram.setUniformMat4("model", mL);
                    gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_INT, 0);
                }
            }

            
            resizeCanvas();
            requestAnimationFrame(renderFunc);
        }
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////MOVIMIENTOS DE LA CAMARA
        var lastX = 0.0;
        var lastY = 0.0;
        var yaw = -90.0; // ajusta según sea necesario
        var pitch = 0.0; // ajusta según sea necesario
        var sensitivity = 0.1; // ajusta según sea necesario


        document.addEventListener('keydown', function (event) {
            const cameraSpeed = 0.1; // ajusta según sea necesario
            const lightMoveSpeed = 0.5;
            switch (event.key) {
                case 'w':
                    vec3.add(cameraPos, cameraPos, vec3.scale(vec3.create(), cameraFront, cameraSpeed));
                    break;
                case 's':
                    vec3.subtract(cameraPos, cameraPos, vec3.scale(vec3.create(), cameraFront, cameraSpeed));
                    break;
                case 'a':
                    vec3.subtract(cameraPos, cameraPos, vec3.scale(vec3.create(), vec3.normalize(vec3.create(), vec3.cross(vec3.create(), cameraFront, cameraUp)), cameraSpeed));
                    break;
                case 'd':
                    vec3.add(cameraPos, cameraPos, vec3.scale(vec3.create(), vec3.normalize(vec3.create(), vec3.cross(vec3.create(), cameraFront, cameraUp)), cameraSpeed));
                    break;
                case 'ArrowUp':
                    vec3.add(cameraPos, cameraPos, vec3.scale(vec3.create(), cameraUp, cameraSpeed));
                    break;
                case 'ArrowDown':
                    vec3.subtract(cameraPos, cameraPos, vec3.scale(vec3.create(), cameraUp, cameraSpeed));
                    break;
                case 'p':
                    vec3.copy(cameraPos, initialCameraPos); // Restablecer posición
                    yaw = -90.0; // Restablecer yaw
                    pitch = 0.0; // Restablecer pitch
                    // Recalcular dirección frontal de la cámara
                    var front = vec3.create();
                    front[0] = Math.cos(glMatrix.glMatrix.toRadian(yaw)) * Math.cos(glMatrix.glMatrix.toRadian(pitch));
                    front[1] = Math.sin(glMatrix.glMatrix.toRadian(pitch));
                    front[2] = Math.sin(glMatrix.glMatrix.toRadian(yaw)) * Math.cos(glMatrix.glMatrix.toRadian(pitch));
                    vec3.normalize(cameraFront, front);
                    break;
                case 'k':
                    cameraPlanet=!cameraPlanet;
                    console.log("CameraPlanet is now:" +cameraPlanet);  // Añadir impresión para depuración

                    break;
            }
        });

        document.addEventListener('mousemove', function (event) {
            if (isMousePressed) {
                var xOffset = event.clientX - lastX;
                var yOffset = lastY - event.clientY; // inverso porque el eje Y del mouse está invertido

                lastX = event.clientX;
                lastY = event.clientY;

                xOffset *= sensitivity;
                yOffset *= sensitivity;

                yaw += xOffset;
                pitch += yOffset;

                // No limitar los ángulos pitch para rotar completamente
                var front = vec3.create();
                front[0] = Math.cos(Math.radians(yaw)) * Math.cos(Math.radians(pitch));
                front[1] = Math.sin(Math.radians(pitch));
                front[2] = Math.sin(Math.radians(yaw)) * Math.cos(Math.radians(pitch));
                vec3.normalize(cameraFront, front);
            }
        });

        var isMousePressed = false;

        document.addEventListener('mousedown', function (event) {
            isMousePressed = true;
            lastX = event.clientX;
            lastY = event.clientY;
        });

        document.addEventListener('mouseup', function () {
            isMousePressed = false;
        });
        function resizeCanvas() {
            const canvas = gl.canvas;
            // Lookup the size the browser is displaying the canvas in CSS pixels.
            const displayWidth = window.innerWidth;
            const displayHeight = window.innerHeight;

            // Check if the canvas is not the same size.
            const needResize = canvas.width !== displayWidth ||
                canvas.height !== displayHeight;

            if (needResize) {
                // Make the canvas the same size
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            }
        }

        renderFunc(0.0);
    </script>
</body>

</html>