<!DOCTYPE html>
<html>
<head>
    <title></title>
    <script type="text/javascript" src="auxiliars.js"></script>
    <script type="text/javascript" src="shader.js"></script>
    <script type="text/javascript" src="ubo.js"></script>
    <script type="text/javascript" src="cube.js"></script>
    <script type="text/javascript" src="gl-matrix.js"></script>
    <script type="text/javascript" src="geometry.js"></script>
    <style type="text/css">
        /*canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        body
        {
            margin: 0;
            overflow: hidden;
        }*/

    </style>
    <script type="text/javascript">
        const mat4 = glMatrix.mat4;
        const vec3 = glMatrix.vec3;
        const vec2 = glMatrix.vec2;
        // Converts from degrees to radians.
        Math.radians = function(degrees) {
          return degrees * Math.PI / 180;
        };
         
        // Converts from radians to degrees.
        Math.degrees = function(radians) {
          return radians * 180 / Math.PI;
        };
    </script>
<script id="shader-vs" type="x-shader/x-vertex">#version 300 es
precision mediump float;
layout (location = 0) in vec3 aPos;

// Unif. Buffer Object
uniform UBO {
    mat4 projection;
    mat4 view;
};

uniform mat4 model;
void main( )
{
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}

</script>

<script id="shader-fs" type="x-shader/x-fragment">#version 300 es
precision mediump float;

out vec4 fragColor;

void main( )
{
    fragColor = vec4( 1.0,1.0,1.0,1.0 );
}
</script>

</head>
<body>
<canvas id="myCanvas" width="500" height="500"></canvas>
<script type="text/javascript">
    const gl = createContext( "myCanvas" );

    // ---------------------------------------------------
    // CREAR TODOS LOS SHADERPROGRAMS QUE NECESITES
    // ---------------------------------------------------
    let shaderProgram = new ShaderProgram( );
    shaderProgram.createVertexShader(
           document.getElementById( "shader-vs" ).text
        );
        shaderProgram.createFragmentShader(
           document.getElementById( "shader-fs" ).text
        );
        shaderProgram.compile( );
        shaderProgram.link( );
        shaderProgram.autocatching( );

    // ---------------------------------------------------
    // CREAMOS EL UBO Y VINCULAMOS TODOS LOS SHADERPROGRAM
    // QUE HARÁN USO DE ESTE UBO
    // ---------------------------------------------------
    // TODO: ShaderProgram debe ser algún Programa que crees y que contenga el UBO
    
    let ubo = new UBO( "UBO", shaderProgram, [ "projection", "view" ]); // Aquí añade todos los uniformes que quieres compartir


    
    // TODO: Realiza esta llamada con cada programa que vayas a utilizar 
    ubo.attachProgram( shaderProgram );



    // ---------------------------------------------------
    // CREA EL VAO, VBO'S Y EBO PARA LA ESFERA (createSphere())
    // CREA EL VAO, VOB'S Y EBO PARA EL ANILLO (createRing())
    //  {
    //    "vertices": vertices,
    //    normals: normals,
    //    texCoords: uvs,
    //    indices: indices
    // }
    // ---------------------------------------------------
    // TODO: Crea una esfera y sube la geometría a la tarjeta gráfica
    const sphereGeo = createSphere( );
    const ringGeo = createRing( );

    var VAO, VBO, VBO2, VBO3, EBO;
        VAO = gl.createVertexArray();
        VBO = gl.createBuffer();
        VBO2 = gl.createBuffer();
        VBO3 = gl.createBuffer();
        EBO = gl.createBuffer ();
        gl.bindVertexArray(VAO);
        // position attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array( sphereGeo.vertices ),
        gl.STATIC_DRAW);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(0);
        // normal attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO2);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array( sphereGeo.normals ),
        gl.STATIC_DRAW);
        gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(1);
        // texCoord attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO3);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array( sphereGeo.textCoords ),
        gl.STATIC_DRAW);
        gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(2);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBO);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array( sphereGeo.indices ),
        gl.STATIC_DRAW);

    const viewPos = vec3.fromValues(5.0, 0.0, 10.0);

    gl.clearColor(1.0, 0.0, 0.2, 1.0);

    gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

    const initialCameraPos = vec3.fromValues(5.0, 0.0, 10.0);
        var cameraPos = vec3.fromValues(5.0, 0.0, 10.0);
        var cameraFront = vec3.fromValues(0.0, 0.0, -1.0);
        var cameraUp = vec3.fromValues(0.0, 1.0, 0.0);

        function updateCameraView(viewMatrix) {
            mat4.lookAt(viewMatrix, cameraPos, vec3.add(vec3.create(), cameraPos, cameraFront), cameraUp);
        }    

    function renderFunc( time )
    {
        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
        gl.enable( gl.DEPTH_TEST );

        //time *= 0.001; // to seconds

    	var proj = mat4.create( );
    	mat4.perspective(proj, Math.radians( 60.0 ), gl.canvas.width/gl.canvas.height, 0.001, 1000.0 );
    	var view = mat4.create( );
        mat4.translate( view, view, [ 0.0, 0.0, -20.0 ] );
        //updateCameraView(view);

        // TODO: Tienes que activar al menos un programa
        shaderProgram.bind( );

        shaderProgram.setUniform3f("viewPos", viewPos[0],viewPos[1],viewPos[2]);

        // Aquí subimos los datos para la proyección y la vista
        ubo.uploadData( "projection", proj );
        ubo.uploadData( "view", view );
        //ubo.uploadData( "model", mat4.create( ) );
        ubo.uploadAll( ); // Esta llamada sube todos los datos de golpe
        
        // A partir de aquí, subimos matriz model y demás cosas para cada esfera.
        var model = mat4.create();
        mat4.rotate(model, model, Math.radians(time), vec3.create(0.5, 0.5, 0));
        shaderProgram.setUniformMat4("model", model);
        // Renderizar la esfera
        gl.bindVertexArray(VAO); // Vincular el VAO de la esfera

        // Dibujar la esfera
        gl.drawElements(gl.TRIANGLES, sphereGeo.indices.length, gl.UNSIGNED_SHORT, 0);


        requestAnimationFrame( renderFunc );
    }

    document.addEventListener('keydown', function(event) {
        /*
            65 => A
            68 => D
            83 => S
            87 => W
            81 => Q
            69 => E

            37 => Flecha izq
            39 => Fecha drcha
            38 => Fecha arriba
            40 => Fecha abajo

        */
        if( event.keyCode == 81 ) // Q
        {
        }
        
    } );

    function resizeCanvas()
    {
        const canvas = gl.canvas;
        // Lookup the size the browser is displaying the canvas in CSS pixels.
        const displayWidth  = window.innerWidth;
        const displayHeight = window.innerHeight;

        // Check if the canvas is not the same size.
        const needResize = canvas.width  !== displayWidth ||
                           canvas.height !== displayHeight;

        if (needResize) {
            // Make the canvas the same size
            canvas.width  = displayWidth;
            canvas.height = displayHeight;
            gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );
        }
    }

    //window.addEventListener('resize', resizeCanvas);
    //resizeCanvas();

    renderFunc( 0.0 );
</script>
</body>
</html>